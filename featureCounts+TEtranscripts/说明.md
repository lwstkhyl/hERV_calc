**生成BAM比对文件（步骤同ERVmap）**：

```sh
threads=10
# 下载序列
cd /home/lwl/Desktop
mkdir fastq && cd fastq
echo -e "SRR521514\nSRR521515" >> cell1.srr
echo -e "SRR521457\nSRR521464" >> cell2.srr
for SRR in $(cat cell1.srr cell2.srr); do
    parallel-fastq-dump --sra-id ${SRR} --threads ${threads} --split-files
done
# 去接头、质控
cat > adapters.fa <<EOF
>TruSeq3-PE-Read1
AGATCGGAAGAGCACACGTCTGAACTCCAGTCA
>TruSeq3-PE-Read2
AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT
EOF
for SRR in $(cat cell1.srr cell2.srr); do
    flexbar -r ${SRR}_1.fastq -p ${SRR}_2.fastq \
    -t ${SRR}_trim \
    -a adapters.fa \
    -m 30 -n ${threads} \
    2> ${SRR}_flexbar.log
done
cd ../
# 构建bowtie2参考基因组
mkdir refs && cd refs
sudo apt-get install aria2
aria2c -x 16 -s 16 https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/latest/hg38.fa.gz
gunzip hg38.fa.gz
bowtie2-build hg38.fa hg38
cd ../
# 比对到基因组（推荐使用--very-sensitive -k 100，这里为了节省时间空间只用-k 20）
for SRR in $(cat fastq/cell1.srr fastq/cell2.srr); do
    bowtie2 -x refs/hg38 -1 fastq/${SRR}_trim_1.fastq -2 fastq/${SRR}_trim_2.fastq \
    -k 20 \
    --no-mixed --no-discordant \
    -p ${threads} \
    2> fastq/${SRR}.bowtie2.log \
    | samtools view -bS - \
    | samtools sort -o fastq/${SRR}.sorted.bam
    samtools index fastq/${SRR}.sorted.bam
done
# 合并技术重复
samtools merge -@ ${threads} fastq/H1.merged.bam $(awk '{print "fastq/"$1".sorted.bam"}' fastq/cell1.srr)
samtools sort -@ ${threads} -o fastq/H1.merged.sorted.bam fastq/H1.merged.bam
samtools index fastq/H1.merged.sorted.bam
samtools merge -@ ${threads} fastq/K562.merged.bam $(awk '{print "fastq/"$1".sorted.bam"}' fastq/cell2.srr)
samtools sort -@ ${threads} -o fastq/K562.merged.sorted.bam fastq/K562.merged.bam
samtools index fastq/K562.merged.sorted.bam
```

**生成hERV的gtf注释**：两种方法，稍后比较下结果

```sh
mkdir gtfs && cd gtfs
wget -c https://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/rmsk.txt.gz
# Gene GTF（GENCODE GRCh38，CHR版）——TEtranscripts使用
aria2c -x 16 -s 16 https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_38/gencode.v38.annotation.gtf.gz
gunzip -f gencode.v38.annotation.gtf.gz
# TE GTF（官方提供的GRCh38 GENCODE匹配版）——TEtranscripts和featureCounts使用
# aria2c -x 16 -s 16 https://labshare.cshl.edu/shares/mhammelllab/www-data/TEtranscripts/TE_GTF/GRCh38_GENCODE_rmsk_TE.gtf.gz
# gunzip -f GRCh38_GENCODE_rmsk_TE.gtf
```

本来是按上面的方法下载，但这个url现已404，使用[自制转座子GTF](https://www.jianshu.com/p/015a04ef8401)

```sh
zcat rmsk.txt.gz | awk 'BEGIN{OFS="\t"}{
  chr=$6; start=$7+1; end=$8; strand=$10; repName=$11; repClass=$12; repFamily=$13;
    fam=repName; gsub("[-_/].*","",fam);
  if(repClass=="LTR" && repName ~ /^HERV/){
    tid=repName"_"chr"_"start"_"end;
    print chr,"hg38_rmsk","exon",start,end,".",strand,".",
          "gene_id \""fam"\"; transcript_id \""tid"\"; family_id \""repFamily"\"; class_id \""repClass"\";";
  }
}' > hg38_hERV_family_1.gtf
zcat rmsk.txt.gz | awk 'BEGIN{OFS="\t"}
function herv_family(repName, repFamily,    fam){
  # 1) 先用 repName 的显式 HERV 名
  if (repName ~ /^HERVK/) return "HERVK"
  if (repName ~ /^HERVH/) return "HERVH"
  if (repName ~ /^HERVW|^HERV17/) return "HERVW"
  if (repName ~ /^HERV9/) return "HERV9"
  # 2) 再把常见 LTR 名映射到对应 HERV family
  if (repName ~ /^LTR5(_Hs|A|B)?/) return "HERVK"   # LTR5/LTR5_Hs 属于 HERVK(HML-2)
  if (repName ~ /^LTR7/)           return "HERVH"   # LTR7 系列属于 HERVH
  if (repName ~ /^LTR17/)          return "HERVW"   # LTR17 系列属于 HERVW
  if (repName ~ /^LTR12/)          return "HERV9"   # LTR12 系列多归于 HERV9
  # 3) 其它情况：不归类（返回空字串 -> 这条记录将被丢弃）
  return ""
}
{
  # rmsk.txt.gz 的字段：... 6:chrom, 7:genoStart, 8:genoEnd, 10:strand, 11:repName, 12:repClass, 13:repFamily
  chr=$6; start=$7+1; end=$8; strand=$10; repName=$11; repClass=$12; repFamily=$13;
  # 只保留 LTR 类
  if (repClass!="LTR") next;
  fam=herv_family(repName, repFamily);
  if (fam=="") next;  # 未能映射到 HERV 家族的忽略
  # TEtranscripts 约定：feature 用 exon；基因/家族聚合用 gene_id；每个拷贝的唯一ID 用 transcript_id
  # family_id 用更细的子家族（这里放 repName），class_id 放 LTR
  tid=repName"_"chr"_"start"_"end;
  print chr,"rmsk","exon",start,end,".",strand,".",
        "gene_id \""fam"\"; transcript_id \""tid"\"; class_id \"LTR\"; family_id \""repName"\";";
}' > hg38_hERV_family_2.gtf
# 在基因组层面：统计family拷贝数&覆盖碱基 
zcat rmsk.txt.gz | awk 'BEGIN{OFS="\t"}{
  chr=$6; start=$7; end=$8; repName=$11; repClass=$12;
  if(repClass=="LTR" && repName ~ /^HERV/){
    fam=repName; gsub("[-_/].*","",fam);
    len=end-start; CNT[fam]++; BP[fam]+=len;
  }
} END {print "family","copies","bp";
        for(f in CNT) print f, CNT[f], BP[f];}' > hERV_family_copy_bp.tsv
cd ../
```

`hg38_hERV_family_2.gtf`约是`_1.gtf`大小的两倍

**单样本分析——使用featureCounts**：以H1细胞系的bam为例

```sh
conda install -c bioconda subread   # 安装featureCounts
mkdir RM_FC && cd RM_FC
featureCounts -a ../gtfs/hg38_hERV_family_1.gtf -t exon -g gene_id \
  -o H1_gtf1_counts_familyLevel.txt \
  -M -O --fraction -T ${threads} -p -B -C \
  ../fastq/H1.merged.sorted.bam
featureCounts -a ../gtfs/hg38_hERV_family_2.gtf -t exon -g gene_id \
  -o H1_gtf2_counts_familyLevel.txt \
  -M -O --fraction -T ${threads} -p -B -C \
  ../fastq/H1.merged.sorted.bam
cd ../
```

---

```sh
# 安装TEtranscripts
cd /home/lwl
git clone https://github.com/mhammell-laboratory/TEtranscripts
cd TEtranscripts
python setup.py install
TEtranscripts --version  # 输出：TEtranscripts 2.2.3
# 安装DESeq2，参考文章：https://zhuanlan.zhihu.com/p/164886255
conda create -n tetranscripts
conda activate tetranscripts
conda install r=3.6
conda install r-xml
conda install -c r r-data.table=1.12.2
conda install -c bioconda bioconductor-deseq2=1.24.0
R  # 打开R环境
install.packages("BiocManager")
BiocManager::install("GenomeInfoDb")  # 不设置镜像，需要挂梯子（国内镜像站没有旧版本BiocManager）
library("DESeq2")  # 检查是否安装成功
# CTRL+Z退出R环境
```

**单样本分析——使用TEcount**：以H1细胞系的bam为例

```sh
cd /home/lwl/Desktop
mkdir TE && cd TE
mkdir H1_gtf1_TEcount
TEcount --sortByPos --format BAM --mode multi \
  -b ../fastq/H1.merged.sorted.bam \
  --GTF ../gtfs/gencode.v38.annotation.gtf \
  --TE  ../gtfs/hg38_hERV_family_1.gtf \
  --stranded no \
  --outdir H1_gtf1_TEcount \
  2> H1_gtf2_TEcount.log
mkdir H1_gtf1_TEcount
TEcount --sortByPos --format BAM --mode multi \
  -b ../fastq/H1.merged.sorted.bam \
  --GTF ../gtfs/gencode.v38.annotation.gtf \
  --TE  ../gtfs/hg38_hERV_family_2.gtf \
  --stranded no \
  --outdir H1_gtf2_TEcount \
  2> H1_gtf2_TEcount.log
```

**多样本差异表达分析——使用TEtranscripts**：
```sh
mkdir H1_K562_gtf1
TEtranscripts --sortByPos --format BAM --mode multi \
  -t $(awk '{printf "../fastq/%s.sorted.bam ",$1}' ../fastq/cell1.srr) \
  -c $(awk '{printf "../fastq/%s.sorted.bam ",$1}' ../fastq/cell2.srr) \
  --GTF ../gtfs/gencode.v38.annotation.gtf \
  --TE  ../gtfs/hg38_hERV_family_1.gtf \
  --stranded no \
  --project H1_K562_gtf1 --outdir H1_K562_gtf1 \
  2> H1_K562_gtf1.log
mkdir H1_K562_gtf2
TEtranscripts --sortByPos --format BAM --mode multi \
  -t $(awk '{printf "../fastq/%s.sorted.bam ",$1}' ../fastq/cell1.srr) \
  -c $(awk '{printf "../fastq/%s.sorted.bam ",$1}' ../fastq/cell2.srr) \
  --GTF ../gtfs/gencode.v38.annotation.gtf \
  --TE  ../gtfs/hg38_hERV_family_2.gtf \
  --stranded no \
  --project H1_K562_gtf2 --outdir H1_K562_gtf2 \
  2> H1_K562_gtf2.log
```

---

因为使用的gtf格式不同，gtf1最后生成的结果基因id格式为`HERVIP10FH:ERV1:LTR`，gtf2为`HERVK:HERVK9-int:LTR`，画图时gtf1就直接取`HERVIP10FH`作为每个点的标注，gtf2按`HERVK`作图例、`HERVK9-int`作为标注

```py
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from adjustText import adjust_text


def volcano(path, plot_name, legend=False):
    df = pd.read_csv(path, sep="\t")
    df.insert(0, 'id', df.index)  # 将行名（基因名）作为一列
    for col in ("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj"):
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")  # 转为数值型
    def parse_herv_family(s):
        if not s.upper().startswith("HERV"):
            return None
        head = s.split(":")[0] if ":" in s else s
        return head  # 仅把以HERV开头的条目标为HERV；其余当作非HERV
    def parse_herv_subfamily(s):
        if not s.upper().startswith("HERV"):
            return None
        head = s.split(":")[1] if ":" in s else s
        return head
    df["HERV_family"] = df["id"].map(parse_herv_family)  # 筛选出HERV家族名
    if legend:
        df["sub_family"] = df["id"].map(parse_herv_subfamily)  # 细分家族名
    df["is_herv"] = df["HERV_family"].notna()
    df = df.dropna(subset=["padj", "log2FoldChange"])
    df["neglog10padj"] = -np.log10(df["padj"].clip(lower=1e-300))  # -log10(padj)
    df["sig"] = (df["padj"] < padj_thr) & (df["log2FoldChange"].abs() >= lfc_thr)  # 根据阈值过滤
    # 画火山图
    fig, ax = plt.subplots(figsize=(8, 6))
    nonsig = df[~df["sig"]]
    sig_herv = df[df["sig"] & df["is_herv"]]
    sig_nonherv = df[df["sig"] & ~df["is_herv"]]
    # 没到阈值的点用灰色
    ax.scatter(nonsig["log2FoldChange"], nonsig["neglog10padj"],
               s=8, alpha=0.35, color="#BFBFBF", edgecolors="none", label="Not significant")
    # 到阈值的非HERV用蓝色
    ax.scatter(sig_nonherv["log2FoldChange"], sig_nonherv["neglog10padj"],
               s=10, alpha=0.6, color="#9ecae1", edgecolors="none", label="Significant non-HERV")
    # 到阈值的HERV用其它颜色
    families = sorted(sig_herv["HERV_family"].unique())
    color_cycle = plt.rcParams["axes.prop_cycle"].by_key().get("color", [])
    fam2color = {fam: color_cycle[i % len(color_cycle)] for i, fam in enumerate(families)}
    for fam in families:
        sub = sig_herv[sig_herv["HERV_family"] == fam]
        ax.scatter(sub["log2FoldChange"], sub["neglog10padj"],
                   s=18, alpha=0.95, color=fam2color[fam], edgecolors="black", linewidths=0.2,
                   label=fam)
    # 阈值线
    ax.axvline(lfc_thr,  color="black", linestyle="--", linewidth=1)
    ax.axvline(-lfc_thr, color="black", linestyle="--", linewidth=1)
    ax.axhline(-np.log10(padj_thr), color="black", linestyle="--", linewidth=1)
    # 轴范围与刻度
    ax.set_xlim(*xlim)
    ax.set_ylim(*ylim)
    ax.set_xticks(np.arange(xlim[0], xlim[1]+1e-9, 2))
    ax.set_yticks(np.arange(ylim[0], ylim[1]+1e-9, 10))
    ax.grid(True, linestyle=":", linewidth=0.6, alpha=0.4)
    # 坐标&标题
    ax.set_xlabel("log2 fold change")
    ax.set_ylabel("-log10(adjusted p-value)")
    # 图例
    if legend:
        handles, labels = ax.get_legend_handles_labels()
        seen = set()  # 去重保持顺序
        new_h, new_l = [], []
        for h, l in zip(handles, labels):
            if l not in seen:
                seen.add(l)
                new_h.append(h)
                new_l.append(l)
        ax.legend(new_h, new_l, loc="upper center", fontsize=8, ncol=1, facecolor="white", framealpha=1)
    # 给显著的HERV加文字标注
    texts = []
    if not sig_herv.empty:
        lab = sig_herv.sort_values("neglog10padj", ascending=False).head(max_labels).copy()
        for i, (_, r) in enumerate(lab.iterrows()):
            dx = 0.3
            dy = 1
            text = ax.annotate(
                r["sub_family"] if legend else r["HERV_family"],
                xy=(r["log2FoldChange"], r["neglog10padj"]),
                xytext=(r["log2FoldChange"] + dx, r["neglog10padj"] + dy),
                textcoords="data",
                fontsize=8,
                color="black",
                arrowprops=dict(arrowstyle="->", color="black", lw=0.8),
                bbox=dict(boxstyle="round,pad=0.2", fc="white", ec="none", alpha=0.6)
            )
            texts.append(text)
    adjust_text(texts)  # 避免文字重叠
    plt.savefig(plot_name+'.pdf')
    # plt.show()
    # 简单输出统计结果
    print(f"-----{plot_name}-----")
    print(f"总条目: {len(df)}")
    print(f"显著（padj<{padj_thr} & |log2FC|>={lfc_thr}）: {df['sig'].sum()}")
    print(f"显著 HERV 条目: {len(sig_herv)}；家族数: {len(families)}")
    print((len(plot_name)+10)*'-')


padj_thr = 0.05
lfc_thr = 1.0
xlim = (-8, 8)  # x轴刻度范围
ylim = (0, 70)  # y轴刻度范围（必须展示到所有标注的点，要不adjust_text会出错）
max_labels = 15  # 最多标注多少个点（按显著性排列）

volcano(r"./TEtranscripts_res/H1_K562_gtf1_TEtranscripts/H1_K562_gtf1_gene_TE_analysis.txt", "H1-K562_gtf1_volcano")
volcano(r"./TEtranscripts_res/H1_K562_gtf2_TEtranscripts/H1_K562_gtf2_gene_TE_analysis.txt", "H1-K562_gtf2_volcano", legend=True)
```
